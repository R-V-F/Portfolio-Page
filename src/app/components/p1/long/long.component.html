<h1>Overview</h1>
<p>
    <span class="grey">dot</span>Canvas is an <a href="https://www.reddit.com/r/place/">r/place</a> inspired app. The idea is to provide users
    with a canvas and let them zoom in to place pixels on it. Anyone connected will be able to
    see the pixels being placed live, which gives the site a 'lively' feel (when populated).</p>
<p>
<p>
    Even though the project does not aim to solve a particular business problem, nor is it particularly entertaining
    without a user base interacting with it, it served as a good template project. For once, it helped me learn more about 
    <span class="orange">Typescript</span>, <span class="orange">Angular</span> and <span class="orange">Firebase</span>,
    incorporating it all into a full stack application. Moreover, it also gave me a lot of insight into how to think about
    the page structure and how to interact with it.
</p>


<h1>Project Structure</h1>
    <img src="assets/project_flow.png" alt="">

<h1>Challenges</h1>
<p>
    Since I'm using <span class="orange">Firebase</span> to handle the backend, - plus not having to worry about scalability issues -
    most of the implementation challenges fell into the frontend side. In particular, the issues that emmerge when changing the
    scale of the canvas, while keeping track of where the tiles must be placed.
</p>
<h2>Scaling the canvas</h2>
    <img src="assets/scaling.png" alt="">
<br>
<br>
<p>
    This is the 'trick' that inspired me to do this project (check out <a href="https://www.redditinc.com/blog/how-we-built-rplace/">How We Built r/Place</a> for more details). 
    The idea is to wrap the canvas with a div, then apply scaling to the div in order to scale the canvas. When I tried it,
    it worked so well that I became really inspired to do my version of the implementation.
</p>

<h2>Positioning the view</h2>
    <img src="assets/positioning.png" alt="">
<br>
<br>
<p>
    After learning how to scale the canvas, the next step was to position the scaled canvas at the clicked pixel.
</p>
<p>
    I was struggling with it in the beginning, because, after scaling, it was hard to know by how much I had to offset the canvas
    in order to keep the clicked pixel at the center of the screen. 
</p>
<p>
    The solution I found was to set <span class="spec">TransformOrigin</span> to a corner (in this case 'top left'). This puts
    the scaled canvas at (0,0) of the viewport. Then,  I just had to offset the canvas by half of the clients' width/height 
    plus the value of the scaled coordinates. 
</p>


<h2>Aligning the Draw Guide</h2>
    <img src="assets/align1.png" alt="">
<br>
<br>
<p>
    The Draw Guide was probably the hardest part of the project, because it must always stay centered relative to the view. 
    Plus, it must stay in sync with the correct pixels that will be painted. 
</p>
<p>
    To do so, I divided the canvas into squares with sides equal to the size of the scale. Then, I search for the closest intersection
    relative to the clicked coordinate and defined that as the origin of the drawing guide.
</p>
    <img src="assets/align_mid.png" alt="">
    <img src="assets/find_intersection.png" alt="">
<p>
    Finally, I offset the position by half of the selected brush size times the scale.
</p>
    <img src="assets/offset mid top.png" alt="">
    <img src="assets/set guide pos.png" alt="">